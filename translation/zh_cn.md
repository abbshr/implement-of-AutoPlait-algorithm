#### abstract
给定一个包含模式不同且数量未知的海量时间序列数据集合.

如何有效并且高效的找出典型的模式和变化点?

如何从统计学角度归纳总结所有的序列,并得到一个有意义的段?

针对如上问题,该论文给出了一个算法autoplait, 具有如下特点:

+ 高效
+ 可扩展(时间复杂度呈线性变化)
+ 参数自由
+ 人类可读(分析结果便于理解)

这个算法目标是完成时间序列的CAPS(数据压缩, 异常检测, 模式提取, 分段).
即分析一个巨大的时间数据集合,并给出数据序列的最佳的表示形式.

autoplait算法可以自动区分并标识出一个时间序列中所有模式(或制式regime),并找出序列中每个模式发生变化时的位置.

#### 其他调查:
对于时间序列的分析包括"模式提取", "总结", "分组", "分段"和"序列匹配".

但是目前针对这些分析的方法至少都需要对算法参数进行人为调整,因此对参数的依赖过于严重.除此之外,对模式的分析也不够准确和清晰.

而理想的方法应该在不涉及人指导和参与的情况下自动提取任意模式.

#### 描述

##### 定义
1. 设序列X为`Bundle`.
   ```
      X = { x1, ..., xn }
   ```
   `X`为一个长度为n的d维时序集合, `xt`为t时刻的d维向量.
2. 设序列中的模式为`Regime`.
   ```
      S = { s1, ..., sm }
   ```
   `S`为包含m个不重叠的段的集合, `si`由某个开始和结束时间段组成的第i个段,即`si = {ts, te}`.
   
   将每一个段分到一个段组(segment group), 从而找到相同模式的段的集合, 这个段组称为`Regime`.
   其中每个段组由统计模型`θi (i = 1, 2, ..., r)`表示.`r`为`regime`的数量.
3. segment-membership
   ```
      F = { f1, ..., fm }
   ```
   `fi (fi -> [1, r])`是第i个段所属的regime编号.
4. 候选式
   ```
      C = { m, r, S, ∅, F }
   ```
   其中`∅ = { θ1, θ2, ..., θr; △r×r }`, `△r×r`描述见下↓.
5. Regime转换矩阵
   `△r×r`为r阶regime的"转换概率矩阵",`Σi,j`表示从第i个regime到第j个regime的转换概率.

**Note: 这里统计模型`θ`由HMM模型表示**

##### `HMM`模型
包含:

+ 模型状态数: `k`
+ 初始化状态概率: `π = { πi }, i = [1, k]`
+ 状态转换概率: `A = { aij }, i,j = [1, k]`
+ 输出概率: `B = { bi(x) }, i = [1, k]`

